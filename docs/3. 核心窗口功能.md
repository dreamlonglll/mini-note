# 阶段二：核心窗口功能

## 目标

实现窗口的透明磨砂效果、桌面嵌入功能、窗口拖拽和位置记忆。

## 任务清单

### 2.1 Windows API 封装

#### Win32Api.cs

```csharp
using System;
using System.Runtime.InteropServices;

namespace MiniNote.Helpers;

/// <summary>
/// Windows API 封装
/// </summary>
public static class Win32Api
{
    #region 窗口查找相关

    [DllImport("user32.dll", SetLastError = true)]
    public static extern IntPtr FindWindow(string? lpClassName, string? lpWindowName);

    [DllImport("user32.dll", SetLastError = true)]
    public static extern IntPtr FindWindowEx(IntPtr hwndParent, IntPtr hwndChildAfter, string? lpszClass, string? lpszWindow);

    [DllImport("user32.dll", SetLastError = true)]
    public static extern IntPtr SetParent(IntPtr hWndChild, IntPtr hWndNewParent);

    [DllImport("user32.dll")]
    public static extern IntPtr GetParent(IntPtr hWnd);

    [DllImport("user32.dll")]
    public static extern bool SetWindowPos(IntPtr hWnd, IntPtr hWndInsertAfter, int X, int Y, int cx, int cy, uint uFlags);

    #endregion

    #region 消息相关

    [DllImport("user32.dll")]
    public static extern IntPtr SendMessage(IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam);

    [DllImport("user32.dll")]
    public static extern IntPtr SendMessageTimeout(IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam, uint fuFlags, uint uTimeout, out IntPtr lpdwResult);

    public const uint SMTO_NORMAL = 0x0000;
    public const uint WM_SPAWN_WORKER = 0x052C;

    #endregion

    #region 窗口样式相关

    [DllImport("user32.dll", SetLastError = true)]
    public static extern int GetWindowLong(IntPtr hWnd, int nIndex);

    [DllImport("user32.dll", SetLastError = true)]
    public static extern int SetWindowLong(IntPtr hWnd, int nIndex, int dwNewLong);

    public const int GWL_EXSTYLE = -20;
    public const int WS_EX_TOOLWINDOW = 0x00000080;
    public const int WS_EX_NOACTIVATE = 0x08000000;

    #endregion

    #region DWM 相关 (磨砂效果)

    [DllImport("dwmapi.dll")]
    public static extern int DwmSetWindowAttribute(IntPtr hwnd, int attr, ref int attrValue, int attrSize);

    [DllImport("dwmapi.dll")]
    public static extern int DwmExtendFrameIntoClientArea(IntPtr hWnd, ref MARGINS pMarInset);

    [StructLayout(LayoutKind.Sequential)]
    public struct MARGINS
    {
        public int cxLeftWidth;
        public int cxRightWidth;
        public int cyTopHeight;
        public int cyBottomHeight;
    }

    // DWM 窗口属性
    public const int DWMWA_USE_IMMERSIVE_DARK_MODE = 20;
    public const int DWMWA_MICA_EFFECT = 1029;
    public const int DWMWA_SYSTEMBACKDROP_TYPE = 38;

    // 系统背景类型
    public const int DWMSBT_MAINWINDOW = 2;      // Mica
    public const int DWMSBT_TRANSIENTWINDOW = 3; // Acrylic
    public const int DWMSBT_TABBEDWINDOW = 4;    // Tabbed

    #endregion

    #region SetWindowPos 标志

    public static readonly IntPtr HWND_BOTTOM = new IntPtr(1);
    public const uint SWP_NOSIZE = 0x0001;
    public const uint SWP_NOMOVE = 0x0002;
    public const uint SWP_NOACTIVATE = 0x0010;

    #endregion
}
```

### 2.2 磨砂效果助手

#### AcrylicHelper.cs

```csharp
using System;
using System.Windows;
using System.Windows.Interop;
using System.Windows.Media;

namespace MiniNote.Helpers;

/// <summary>
/// 磨砂效果助手类
/// </summary>
public static class AcrylicHelper
{
    /// <summary>
    /// 为窗口启用 Acrylic 磨砂效果 (Windows 11)
    /// </summary>
    public static bool EnableAcrylic(Window window)
    {
        try
        {
            var hwnd = new WindowInteropHelper(window).Handle;
            if (hwnd == IntPtr.Zero) return false;

            // 设置窗口背景为透明
            window.Background = Brushes.Transparent;

            // 尝试启用 Acrylic 效果 (Windows 11)
            int backdropType = Win32Api.DWMSBT_TRANSIENTWINDOW;
            int result = Win32Api.DwmSetWindowAttribute(
                hwnd,
                Win32Api.DWMWA_SYSTEMBACKDROP_TYPE,
                ref backdropType,
                sizeof(int)
            );

            if (result == 0)
            {
                // 扩展帧到客户区
                var margins = new Win32Api.MARGINS { cxLeftWidth = -1 };
                Win32Api.DwmExtendFrameIntoClientArea(hwnd, ref margins);
                return true;
            }

            // 如果 Acrylic 失败，尝试 Mica
            return EnableMica(window);
        }
        catch
        {
            return false;
        }
    }

    /// <summary>
    /// 为窗口启用 Mica 效果 (Windows 11)
    /// </summary>
    public static bool EnableMica(Window window)
    {
        try
        {
            var hwnd = new WindowInteropHelper(window).Handle;
            if (hwnd == IntPtr.Zero) return false;

            window.Background = Brushes.Transparent;

            int backdropType = Win32Api.DWMSBT_MAINWINDOW;
            int result = Win32Api.DwmSetWindowAttribute(
                hwnd,
                Win32Api.DWMWA_SYSTEMBACKDROP_TYPE,
                ref backdropType,
                sizeof(int)
            );

            if (result == 0)
            {
                var margins = new Win32Api.MARGINS { cxLeftWidth = -1 };
                Win32Api.DwmExtendFrameIntoClientArea(hwnd, ref margins);
                return true;
            }

            return false;
        }
        catch
        {
            return false;
        }
    }

    /// <summary>
    /// 设置深色模式
    /// </summary>
    public static void SetDarkMode(Window window, bool isDark)
    {
        try
        {
            var hwnd = new WindowInteropHelper(window).Handle;
            if (hwnd == IntPtr.Zero) return;

            int value = isDark ? 1 : 0;
            Win32Api.DwmSetWindowAttribute(
                hwnd,
                Win32Api.DWMWA_USE_IMMERSIVE_DARK_MODE,
                ref value,
                sizeof(int)
            );
        }
        catch
        {
            // 忽略错误
        }
    }
}
```

### 2.3 桌面嵌入服务

#### DesktopEmbedService.cs

```csharp
using System;
using System.Windows;
using System.Windows.Interop;

namespace MiniNote.Services;

/// <summary>
/// 桌面嵌入服务 - 将窗口嵌入到桌面壁纸层
/// </summary>
public class DesktopEmbedService
{
    private IntPtr _workerW = IntPtr.Zero;
    private IntPtr _originalParent = IntPtr.Zero;

    /// <summary>
    /// 将窗口嵌入桌面
    /// </summary>
    public bool EmbedToDesktop(Window window)
    {
        try
        {
            var hwnd = new WindowInteropHelper(window).Handle;
            if (hwnd == IntPtr.Zero) return false;

            // 保存原始父窗口
            _originalParent = Helpers.Win32Api.GetParent(hwnd);

            // 获取桌面 WorkerW 窗口
            _workerW = GetDesktopWorkerW();
            if (_workerW == IntPtr.Zero) return false;

            // 设置窗口样式，避免在任务栏显示
            int exStyle = Helpers.Win32Api.GetWindowLong(hwnd, Helpers.Win32Api.GWL_EXSTYLE);
            exStyle |= Helpers.Win32Api.WS_EX_TOOLWINDOW;
            Helpers.Win32Api.SetWindowLong(hwnd, Helpers.Win32Api.GWL_EXSTYLE, exStyle);

            // 将窗口设置为 WorkerW 的子窗口
            Helpers.Win32Api.SetParent(hwnd, _workerW);

            return true;
        }
        catch
        {
            return false;
        }
    }

    /// <summary>
    /// 取消桌面嵌入
    /// </summary>
    public void DetachFromDesktop(Window window)
    {
        try
        {
            var hwnd = new WindowInteropHelper(window).Handle;
            if (hwnd == IntPtr.Zero) return;

            // 恢复原始父窗口
            Helpers.Win32Api.SetParent(hwnd, _originalParent);

            // 移除工具窗口样式
            int exStyle = Helpers.Win32Api.GetWindowLong(hwnd, Helpers.Win32Api.GWL_EXSTYLE);
            exStyle &= ~Helpers.Win32Api.WS_EX_TOOLWINDOW;
            Helpers.Win32Api.SetWindowLong(hwnd, Helpers.Win32Api.GWL_EXSTYLE, exStyle);
        }
        catch
        {
            // 忽略错误
        }
    }

    /// <summary>
    /// 获取桌面 WorkerW 窗口句柄
    /// </summary>
    private IntPtr GetDesktopWorkerW()
    {
        // 获取 Progman 窗口
        IntPtr progman = Helpers.Win32Api.FindWindow("Progman", null);
        if (progman == IntPtr.Zero) return IntPtr.Zero;

        // 发送消息让 Windows 创建 WorkerW
        Helpers.Win32Api.SendMessageTimeout(
            progman,
            Helpers.Win32Api.WM_SPAWN_WORKER,
            IntPtr.Zero,
            IntPtr.Zero,
            Helpers.Win32Api.SMTO_NORMAL,
            1000,
            out _
        );

        // 查找 WorkerW 窗口
        IntPtr workerW = IntPtr.Zero;
        IntPtr shell = Helpers.Win32Api.FindWindowEx(IntPtr.Zero, IntPtr.Zero, "WorkerW", null);

        while (shell != IntPtr.Zero)
        {
            IntPtr defView = Helpers.Win32Api.FindWindowEx(shell, IntPtr.Zero, "SHELLDLL_DefView", null);
            if (defView != IntPtr.Zero)
            {
                // 找到包含 SHELLDLL_DefView 的 WorkerW，我们需要的是下一个
                workerW = Helpers.Win32Api.FindWindowEx(IntPtr.Zero, shell, "WorkerW", null);
                break;
            }
            shell = Helpers.Win32Api.FindWindowEx(IntPtr.Zero, shell, "WorkerW", null);
        }

        return workerW;
    }
}
```

### 2.4 主窗口实现

#### MainWindow.xaml

```xml
<Window x:Class="MiniNote.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="MiniNote"
        Width="300"
        Height="400"
        WindowStyle="None"
        AllowsTransparency="True"
        Background="Transparent"
        ResizeMode="CanResizeWithGrip"
        ShowInTaskbar="False"
        Topmost="True"
        MouseLeftButtonDown="Window_MouseLeftButtonDown"
        Loaded="Window_Loaded"
        Closing="Window_Closing">
    
    <Border CornerRadius="8"
            Background="#E6202020"
            BorderBrush="#40FFFFFF"
            BorderThickness="1">
        <Grid>
            <Grid.RowDefinitions>
                <RowDefinition Height="32"/>
                <RowDefinition Height="*"/>
            </Grid.RowDefinitions>
            
            <!-- 标题栏 -->
            <Border Grid.Row="0" 
                    Background="#30FFFFFF"
                    CornerRadius="8,8,0,0">
                <Grid>
                    <TextBlock Text="MiniNote" 
                               Foreground="White"
                               FontWeight="SemiBold"
                               VerticalAlignment="Center"
                               Margin="12,0,0,0"/>
                    
                    <StackPanel Orientation="Horizontal"
                                HorizontalAlignment="Right"
                                Margin="0,0,4,0">
                        <Button x:Name="BtnSettings"
                                Content="&#xE713;"
                                FontFamily="Segoe MDL2 Assets"
                                Style="{StaticResource TitleBarButtonStyle}"
                                Click="BtnSettings_Click"/>
                        <Button x:Name="BtnMinimize"
                                Content="&#xE921;"
                                FontFamily="Segoe MDL2 Assets"
                                Style="{StaticResource TitleBarButtonStyle}"
                                Click="BtnMinimize_Click"/>
                    </StackPanel>
                </Grid>
            </Border>
            
            <!-- 内容区域 -->
            <Grid Grid.Row="1" Margin="8">
                <!-- 待办列表将在此处添加 -->
                <TextBlock Text="待办列表区域"
                           Foreground="#80FFFFFF"
                           HorizontalAlignment="Center"
                           VerticalAlignment="Center"/>
            </Grid>
        </Grid>
    </Border>
</Window>
```

#### MainWindow.xaml.cs

```csharp
using System.Windows;
using System.Windows.Input;
using MiniNote.Helpers;
using MiniNote.Services;
using MiniNote.Models;

namespace MiniNote;

public partial class MainWindow : Window
{
    private readonly DesktopEmbedService _embedService;
    private readonly DatabaseService _dbService;
    private AppSettings _settings = null!;

    public MainWindow()
    {
        InitializeComponent();
        _embedService = new DesktopEmbedService();
        _dbService = new DatabaseService();
    }

    private async void Window_Loaded(object sender, RoutedEventArgs e)
    {
        // 加载设置
        _settings = await _dbService.GetSettingsAsync();
        
        // 应用窗口位置和大小
        Left = _settings.WindowX;
        Top = _settings.WindowY;
        Width = _settings.WindowWidth;
        Height = _settings.WindowHeight;

        // 启用磨砂效果
        AcrylicHelper.EnableAcrylic(this);
        AcrylicHelper.SetDarkMode(this, true);

        // 嵌入桌面
        if (_settings.EmbedDesktop)
        {
            _embedService.EmbedToDesktop(this);
        }
    }

    private async void Window_Closing(object sender, System.ComponentModel.CancelEventArgs e)
    {
        // 保存窗口位置和大小
        _settings.WindowX = Left;
        _settings.WindowY = Top;
        _settings.WindowWidth = Width;
        _settings.WindowHeight = Height;
        await _dbService.SaveSettingsAsync(_settings);

        // 取消桌面嵌入
        _embedService.DetachFromDesktop(this);
    }

    private void Window_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
    {
        // 允许拖动窗口
        if (e.LeftButton == MouseButtonState.Pressed)
        {
            DragMove();
        }
    }

    private void BtnSettings_Click(object sender, RoutedEventArgs e)
    {
        // TODO: 打开设置窗口
    }

    private void BtnMinimize_Click(object sender, RoutedEventArgs e)
    {
        // 最小化到托盘（后续实现）
        WindowState = WindowState.Minimized;
    }
}
```

### 2.5 窗口样式资源

#### App.xaml 添加样式

```xml
<Application.Resources>
    <!-- 标题栏按钮样式 -->
    <Style x:Key="TitleBarButtonStyle" TargetType="Button">
        <Setter Property="Width" Value="28"/>
        <Setter Property="Height" Value="28"/>
        <Setter Property="FontSize" Value="10"/>
        <Setter Property="Foreground" Value="White"/>
        <Setter Property="Background" Value="Transparent"/>
        <Setter Property="BorderThickness" Value="0"/>
        <Setter Property="Cursor" Value="Hand"/>
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="Button">
                    <Border x:Name="border"
                            Background="{TemplateBinding Background}"
                            CornerRadius="4">
                        <ContentPresenter HorizontalAlignment="Center"
                                          VerticalAlignment="Center"/>
                    </Border>
                    <ControlTemplate.Triggers>
                        <Trigger Property="IsMouseOver" Value="True">
                            <Setter TargetName="border" Property="Background" Value="#40FFFFFF"/>
                        </Trigger>
                        <Trigger Property="IsPressed" Value="True">
                            <Setter TargetName="border" Property="Background" Value="#60FFFFFF"/>
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
</Application.Resources>
```

## 验收标准

- [ ] 窗口显示透明磨砂背景效果
- [ ] 窗口成功嵌入桌面壁纸层
- [ ] 按 Win+D 不会最小化窗口
- [ ] 窗口可以拖拽移动
- [ ] 关闭后重新打开能记住位置

## 注意事项

1. 透明磨砂效果需要 Windows 10 1903+ 或 Windows 11
2. 嵌入桌面后窗口不会显示在任务栏
3. 嵌入桌面会使窗口始终在其他窗口下方（壁纸层）
4. 如果用户更换壁纸，可能需要重新嵌入
